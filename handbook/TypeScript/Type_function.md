## Ссылки
- https://metanit.com/web/typescript/2.3.php (metanit)

---
## Содержание

- [Тип функции](#тип-функции)
- [Функции как параметры других функций](#функции-как-параметры-других-функций)

---

## Тип функции

>**Тип функции** - комбинация типов параметров и типа возвращаемого значения. 

В общем виде определение типа функции выглядит следующим образом:

    (параметр1: тип, параметр2: тип,...параметрN: тип) => тип_результата;

В `( )` идет перечисление через запятую параметров и их типов. После списка параметров через оператор => указывается тип возвращаемого функцией результата.

Например, возьмем следующую функцию:

    function hello () {
        console.log("Hello TypeScript");
    };

Эта функция не имеет параметров и ничего не возвращает. Если функция ничего не возвращает, то фактически тип ее возвращаемого значения - void. Таким образом, функция `hello` имеет тип

    ()=>void;

Используя тип функции, мы можем определить переменные, константы и параметры этого типа. Например:

    function hello (){
        console.log("Hello TypeScript");
    };
    
    let message: ()=>void = hello;
    message();

В данном случае переменная `message` представляет любую функцию, которая не принимает параметров и ничего не возвращает.

Другой пример - функция, которая принимает параметры и возвращает некоторый результат:

    function sum (x: number, y: number): number {
        return x + y;
    };

Она имеет тип `(x:number, y:number) => number;`, то есть принимает два параметра `number` и возвращает значение типа `number`.

Также мы можем определять значения этого типа функции:

    let op: (x:number, y:number) => number;

То есть переменная `op` представляет любую функцию, которая принимает два числа и которая возвращает число. Например:

    function sum (x: number, y: number): number {
        return x + y;
    };
    function subtract (a: number, b: number): number {
        return a - b;
    };
    
    let op: (x:number, y:number) => number;
    
    op = sum;
    console.log(op(2, 4));  // 6
    
    op = subtract;
    console.log(op(6, 4));  // 2

Здесь вначале переменная `op` указывает на функцию `sum`. И соответственно вызов `op(2, 4)` фактически будет представлять вызов `sum(2, 4)`. А затем `op` указывает на функцию `subtract`.

[вернуться к содержанию...](#содержание)

---

## Функции как параметры других функций

Тип функции можно использовать как тип переменной, но он также может применяться для определения типа параметра другой функции:

    function sum (x: number, y: number): number {
        return x + y;
    };
    function multiply (a: number, b: number): number {
        return a * b;
    };
    
    function mathOp(x: number, y: number, op: (a: number, b: number) => number): number{
    
        return op(x, y);
    }
    console.log(mathOp(10, 20, sum)); // 30 
    console.log(mathOp(10, 20, multiply)); // 200 

Здесь в функции `mathOp()` третий параметр представляет функцию, которая принимает два параметра типа number и возвращает значение типа number. Соответственно при вызове функции `mathOp()` мы можем передать в нее, например, определенные здесь функции `sum()` или `multiply()`, которые соответствуют типу `(a: number, b: number) => number`

Если определенный тип функции предстоит очень часто использовать, то для него оптимальнее определить **псевдоним** и обращаться к типу по этому псевдониму:

    type Operation = (a: number, b: number) => number; // псевдоним
    
    function mathOp(x: number, y: number, op: Operation): number{
    
        return op(x, y);
    }
    let sum: Operation = function(x: number, y: number): number {
        return x + y;
    };
    
    console.log(mathOp(10, 20, sum)); // 30

В данном случае тип `(a: number, b: number) => number` проецируется на псевдоним `Operation`, который может использоваться для определения переменных и параметров.

[вернуться к содержанию...](#содержание)